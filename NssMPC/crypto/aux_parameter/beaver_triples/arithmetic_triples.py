import os
import random
import re
from NssMPC.crypto.aux_parameter import Parameter
from NssMPC.common.ring import RingTensor
from NssMPC.common.utils import cuda_matmul
from NssMPC.config import param_path
from NssMPC.crypto.primitives.homomorphic_encryption.paillier import Paillier


class AssMulTriples(Parameter):
    def __init__(self):
        self.a = None
        self.b = None
        self.c = None
        self.size = 0

    def __iter__(self):
        return iter((self.a, self.b, self.c))

    # def set_name(self, name):
    #     self.name = name
    #
    def set_party(self, party):
        self.a.party = party
        self.b.party = party
        self.c.party = party

    #
    def set_triples(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    @staticmethod
    def gen(num_of_triples, num_of_party=2, type_of_generation='TTP', party=None):
        """
        Generate multiplicative Beaver triples

        Args:
            num_of_triples: the number of triples
            num_of_party: the number of parties
            type_of_generation: generation type,
                                TTP: generated by trusted third party,
                                HE: generated by homomorphic encryption,
            party: x_shape if MAT or party if HE \n
        """
        if type_of_generation == 'HE':
            return gen_triples_by_homomorphic_encryption(num_of_triples, party)
        elif type_of_generation == 'TTP':
            return gen_triples_by_ttp(num_of_triples, num_of_party, share_type='normal')

    @classmethod
    def gen_and_save(cls, num, num_of_party=2, saved_name=None, saved_path=None, type_of_generation='TTP', party=None):
        """
        Generate and save multiplicative Beaver triples

        Args:
            num: the number of triples
            num_of_party: the number of parties
            type_of_generation: generation type,
                                TTP: generated by trusted third party,
                                HE: generated by homomorphic encryption,
            saved_name: saved name for the generated params
            saved_path: saved path for the generated params
            party: party if HE \n
        """
        triples = cls.gen(num, num_of_party, type_of_generation, party)
        if saved_path is None:
            file_path = f"{param_path}AssMulTriples/"
        else:
            file_path = saved_path
        if not os.path.exists(file_path):
            os.makedirs(file_path)

        if saved_name is None:
            saved_name = 'AssMulTriples'

        if type_of_generation == 'TTP':
            for i in range(num_of_party):
                file_name = f"{saved_name}_{i}.pth"
                triples[i].save(file_path=file_path, name=file_name)

        # todo HE部分没有做适配
        elif type_of_generation == 'HE':
            file_names = os.listdir(file_path)
            max_ptr = 0
            for fname in file_names:
                match = re.search(rf"AssMulTriples{party.party_id}+_(\d+)\.pth", fname)
                if match:
                    max_ptr = max(max_ptr, int(match.group(1)))
            file_name = f"AssMulTriples_{party.party_id}_{max_ptr + 1}.pth"
            triples.save(file_path=file_path, name=file_name)


class RssMulTriples(Parameter):
    def __init__(self):
        self.a = None
        self.b = None
        self.c = None
        self.size = 0

    def __iter__(self):
        return iter((self.a, self.b, self.c))

    def set_party(self, party):
        self.a.party = party
        self.b.party = party
        self.c.party = party

    def set_triples(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    @staticmethod
    def gen(num_of_triples):
        """
        Generate multiplicative Beaver triples

        Args:
            num_of_triples: the number of triples
        """

        return gen_triples_by_ttp(num_of_triples, num_of_party=3, share_type='replicate')

    @classmethod
    def gen_and_save(cls, num, type_of_generation='TTP', party=None):
        """
        Generate and save multiplicative Beaver triples

        Args:
            num: the number of triples
            type_of_generation: generation type,
                                TTP: generated by trusted third party,
                                HE: generated by homomorphic encryption,
            party: party if HE \n
        """
        triples = cls.gen(num)
        if type_of_generation == 'TTP':
            file_path = f"{param_path}RssMulTriples/"
            if not os.path.exists(file_path):
                os.makedirs(file_path)
            for i in range(3):
                file_name = f"RssMulTriples_{i}.pth"
                triples[i].save(file_path, file_name)


def gen_triples_by_ttp(num_of_triples, num_of_party, share_type='normal'):
    """
    Generate the multiplication Beaver triple by trusted third party

    Args:
        num_of_triples: the number of triples
        num_of_party: the number of party,
        share_type: share type, normal or replicate
    Returns:
        the multiplication triple
    """

    a = RingTensor.random([num_of_triples])
    b = RingTensor.random([num_of_triples])
    c = a * b
    if share_type == 'normal':
        from NssMPC.crypto.primitives.arithmetic_secret_sharing.arithmetic_secret_sharing import ArithmeticSecretSharing
        a_list = ArithmeticSecretSharing.share(a, num_of_party)
        b_list = ArithmeticSecretSharing.share(b, num_of_party)
        c_list = ArithmeticSecretSharing.share(c, num_of_party)
        triples = []
        for i in range(num_of_party):
            triples.append(AssMulTriples())
            triples[i].a = a_list[i].to('cpu')
            triples[i].b = b_list[i].to('cpu')
            triples[i].c = c_list[i].to('cpu')
            triples[i].size = num_of_triples
        return triples
    elif share_type == 'replicate':
        from NssMPC.crypto.primitives.arithmetic_secret_sharing.replicated_secret_sharing import ReplicatedSecretSharing
        a_list = ReplicatedSecretSharing.share(a)
        b_list = ReplicatedSecretSharing.share(b)
        c_list = ReplicatedSecretSharing.share(c)
        triples = []
        for i in range(num_of_party):
            triples.append(RssMulTriples())
            triples[i].a = a_list[i].to('cpu')
            triples[i].b = b_list[i].to('cpu')
            triples[i].c = c_list[i].to('cpu')
            triples[i].size = num_of_triples
        return triples
    else:
        raise TypeError("Share type not supported")


def gen_triples_by_homomorphic_encryption(num_of_triples, party):
    """
    Generate the multiplication Beaver triple by homomorphic encryption

    Args:
        num_of_triples: the number of triples
        party: the party to get triples

    Returns:
        the multiplication triple
    """
    a = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
    b = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
    c = []

    if party.party_id == 0:
        paillier = Paillier()
        paillier.gen_keys()

        encrypted_a = paillier.encrypt(a)
        encrypted_b = paillier.encrypt(b)

        party.send([encrypted_a, encrypted_b, paillier.public_key])

        d = party.receive()
        decrypted_d = paillier.decrypt(d)
        c = [decrypted_d[i] + a[i] * b[i] for i in range(num_of_triples)]

    elif party.party_id == 1:

        r = [random.randint(0, 2 ^ 32) for _ in range(num_of_triples)]
        c = [a[i] * b[i] - r[i] for i in range(num_of_triples)]

        messages = party.receive()

        encrypted_r = Paillier.encrypt_with_key(r, messages[2])
        d = [messages[0][i] ** b[i] * messages[1][i] ** a[i] * encrypted_r[i] for i in range(num_of_triples)]

        party.send(d)

    triples = AssMulTriples()
    from NssMPC.crypto.primitives.arithmetic_secret_sharing.arithmetic_secret_sharing import ArithmeticSecretSharing
    triples.a = ArithmeticSecretSharing(RingTensor(a).to('cpu'), party)
    triples.b = ArithmeticSecretSharing(RingTensor(b).to('cpu'), party)
    triples.c = ArithmeticSecretSharing(RingTensor(c).to('cpu'), party)
    triples.size = num_of_triples

    return triples


class MatmulTriples(AssMulTriples):
    @staticmethod
    def gen(num_of_triples, x_shape=None, y_shape=None, num_of_party=2):
        """
        Generate multiplicative Beaver triples

        Args:
            num_of_triples: the number of triples
            num_of_party: the number of parties
            x_shape: the shape of the matrix x
            y_shape: the shape of the matrix y
        """
        return gen_matrix_triples_by_ttp(num_of_triples, x_shape, y_shape, num_of_party)

    # @classmethod
    # def gen_and_save(cls, num_of_triples, x_shape=None, y_shape=None, num_of_party=2):
    #     """
    #     Generate and save multiplicative Beaver triples
    #
    #     Args:
    #         num_of_triples: the number of triples
    #         num_of_party: the number of parties
    #         x_shape: the shape of the matrix x
    #         y_shape: the shape of the matrix y
    #     """
    #     triples = cls.gen(num_of_triples, x_shape, y_shape, num_of_party)
    #     for party_id in range(num_of_party):
    #         file_path = base_path + f"/aux_parameters/BeaverTriples/{num_of_party}party/Matrix"
    #         file_name = f"MatrixBeaverTriples_{party_id}_{list(x_shape)}_{list(y_shape)}.pth"
    #         triples[party_id].save_by_name(file_name, file_path)


def gen_matrix_triples_by_ttp(num_of_param, x_shape, y_shape, num_of_party=2):
    """
    Generate the matrix multiplication Beaver triple by trusted third party

    Args:
        num_of_param: the number of matrix Beaver triples to need
        x_shape: the shape of the matrix x
        y_shape: the shape of the matrix y
        num_of_party: the number of party

    Returns:
        the matrix multiplication Beaver triples
    """
    x_shape = [num_of_param] + list(x_shape)
    y_shape = [num_of_param] + list(y_shape)
    a = RingTensor.random(x_shape)
    b = RingTensor.random(y_shape)
    if a.device == 'cpu':
        c = a @ b
    else:
        c = cuda_matmul(a.tensor, b.tensor)
        c = RingTensor.convert_to_ring(c)

    # print("ori a", a)
    # print("ori b", b)
    # print("ori c", c)

    # todo 这里需要修改share_type 等千行分离以后搞
    if num_of_party == 2:
        from NssMPC.crypto.primitives.arithmetic_secret_sharing.arithmetic_secret_sharing import ArithmeticSecretSharing
        a_list = ArithmeticSecretSharing.share(a, num_of_party)
        b_list = ArithmeticSecretSharing.share(b, num_of_party)
        c_list = ArithmeticSecretSharing.share(c, num_of_party)
        triples = []
        for i in range(num_of_party):
            triples.append(MatmulTriples())
            triples[i].a = a_list[i].to('cpu')
            triples[i].b = b_list[i].to('cpu')
            triples[i].c = c_list[i].to('cpu')

        return triples
    elif num_of_party == 3:
        # print("3pc_rss share")
        from NssMPC.crypto.primitives.arithmetic_secret_sharing.replicated_secret_sharing import ReplicatedSecretSharing
        a_list = ReplicatedSecretSharing.share(a)
        b_list = ReplicatedSecretSharing.share(b)
        c_list = ReplicatedSecretSharing.share(c)
        triples = []
        for i in range(num_of_party):
            # print("*****************")
            # print(i)
            triples.append(RssMatmulTriples())
            triples[i].a = a_list[i].to('cpu')
            # print(triples[i].a)
            triples[i].b = b_list[i].to('cpu')
            # print(triples[i].b)
            triples[i].c = c_list[i].to('cpu')
            # print(triples[i].c)
            # print("*****************")
        return triples
    else:
        raise TypeError("Share type not supported")


class RssMatmulTriples(RssMulTriples):
    @staticmethod
    def gen(num_of_triples, x_shape=None, y_shape=None, num_of_party=3):
        """
        Generate multiplicative Beaver triples

        Args:
            num_of_triples: the number of triples
            num_of_party: the number of parties
            x_shape: the shape of the matrix x
            y_shape: the shape of the matrix y
        """
        return gen_matrix_triples_by_ttp(num_of_triples, x_shape, y_shape, num_of_party)
