import torch

from NssMPC.common.random import PRG
from NssMPC.common.utils import convert_tensor
from NssMPC.config import data_type, DEVICE, LAMBDA, HALF_RING, PRG_TYPE, BIT_LEN
from NssMPC.crypto.aux_parameter import Parameter
from NssMPC.crypto.aux_parameter.function_secret_sharing_keys.cw import CW, CWList


class DCFKey(Parameter):
    """
    The secret sharing key for distributed comparison function

    Attributes:
        s: the parameter, a binary string with λ bits, of root node generated by DCF
        cw_list: the list of the correct word
        ex_cw_dcf: the extra check word used for dpf calculation
    """

    def __init__(self):
        self.s = None
        self.cw_list = CWList()
        self.ex_cw_dcf = None
        self.size = 0

    @staticmethod
    def gen(num_of_keys, alpha, beta):
        """
        The api generating DCF key, which can generate multiple keys.
        Distributed point function:
            f(x)=b, if x < α; f(x)=0, else

        Args:
            num_of_keys: the number of keyes needed
            alpha: the parameter alpha of dcf
            beta: the parameter beta of dcf

        Returns:
            the participants' keyes
        """
        seed_0 = torch.randint(-HALF_RING, HALF_RING - 1, [num_of_keys, LAMBDA // BIT_LEN], dtype=data_type,
                               device=DEVICE)
        seed_1 = torch.randint(-HALF_RING, HALF_RING - 1, [num_of_keys, LAMBDA // BIT_LEN], dtype=data_type,
                               device=DEVICE)

        prg = PRG(PRG_TYPE, device=DEVICE)
        prg.set_seeds(seed_0)
        s_0_0 = prg.bit_random_tensor(LAMBDA)
        prg.set_seeds(seed_1)
        s_0_1 = prg.bit_random_tensor(LAMBDA)

        k0 = DCFKey()
        k1 = DCFKey()

        k0.s = s_0_0
        k1.s = s_0_1

        s_last_0 = s_0_0
        s_last_1 = s_0_1

        t_last_0 = torch.zeros(num_of_keys, 1, dtype=data_type, device=DEVICE)
        t_last_1 = torch.ones(num_of_keys, 1, dtype=data_type, device=DEVICE)

        v_a = torch.zeros((num_of_keys, 1), dtype=data_type, device=DEVICE)

        for i in range(alpha.bit_len):
            s_l_0, v_l_0, t_l_0, s_r_0, v_r_0, t_r_0 = CW.gen_dcf_cw(prg, s_last_0, LAMBDA)
            s_l_1, v_l_1, t_l_1, s_r_1, v_r_1, t_r_1 = CW.gen_dcf_cw(prg, s_last_1, LAMBDA)

            cond = (alpha.get_tensor_bit(alpha.bit_len - 1 - i) == 0).view(-1, 1)

            l_tensors = [s_l_0, s_l_1, v_l_0, v_l_1, t_l_0, t_l_1]
            r_tensors = [s_r_0, s_r_1, v_r_0, v_r_1, t_r_0, t_r_1]
            keep_tensors = [torch.where(cond, l, r) for l, r in zip(l_tensors, r_tensors)]
            lose_tensors = [torch.where(cond, r, l) for l, r in zip(l_tensors, r_tensors)]

            s_keep_0, s_keep_1, v_keep_0, v_keep_1, t_keep_0, t_keep_1 = keep_tensors
            s_lose_0, s_lose_1, v_lose_0, v_lose_1, t_lose_0, t_lose_1 = lose_tensors

            s_cw = s_lose_0 ^ s_lose_1

            v_cw = pow(-1, t_last_1) * (convert_tensor(v_lose_1) - convert_tensor(v_lose_0) - v_a)

            v_cw = torch.where(alpha.get_tensor_bit(alpha.bit_len - 1 - i) == 1, v_cw + pow(-1, t_last_1) * beta.tensor,
                               v_cw)

            v_a = (v_a
                   - convert_tensor(v_keep_1)
                   + convert_tensor(v_keep_0)
                   + pow(-1, t_last_1) * v_cw)

            t_l_cw = t_l_0 ^ t_l_1 ^ ~cond ^ 1
            t_r_cw = t_r_0 ^ t_r_1 ^ ~cond

            cw = CW(s_cw=s_cw, v_cw=v_cw, t_cw_l=t_l_cw, t_cw_r=t_r_cw, lmd=LAMBDA)

            k0.cw_list.append(cw)
            k1.cw_list.append(cw)

            t_keep_cw = torch.where(cond, t_l_cw, t_r_cw)

            s_last_0 = s_keep_0 ^ (t_last_0 * s_cw)
            s_last_1 = s_keep_1 ^ (t_last_1 * s_cw)

            t_last_0 = t_keep_0 ^ (t_last_0 * t_keep_cw)
            t_last_1 = t_keep_1 ^ (t_last_1 * t_keep_cw)

        k0.ex_cw_dcf = k1.ex_cw_dcf = pow(-1, t_last_1) * (
                convert_tensor(s_last_1)
                - convert_tensor(s_last_0)
                - v_a[:, 0].view(-1, 1))

        return k0, k1
